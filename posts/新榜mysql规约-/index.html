<!doctype html>
<html lang="en-us">
  <head>
    <title>新榜mysql规约 // 有度规约</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.84.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://yuyou80.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="新榜mysql规约"/>
<meta name="twitter:description" content="新榜mysql规约** 概要 想要发挥 MySQL 的最佳性能，需要遵循 3 个基本使用原则：
 首先是需要让 MySQL 回归存储的基本职能：MySQL 数据库只用于数据的存储，不进行数据的复杂计算，不承载业务逻辑，确保存储和计算分离； 其次是查询数据时，尽量单表查询，减少跨库查询和多表关联； 还有就是要杜绝大事务、大 SQL、大批量、大字段等一系列性能杀手。 • 大事务，运行步骤较多，涉及的表和字段较多，容易造成资源的争抢，甚至形成死锁。一旦事务回滚，会导致资源占用时间过长。 • 大 SQL，复杂的 SQL 意味着过多的表的关联，MySQL 数据库处理关联超过 3 张表以上的 SQL 时，占用资源多，性能低下。 • 大批量，意味着多条 SQL 一次性执行完成，必须确保进行充分的测试，并且在业务低峰时段或者非业务时段执行。 • 大字段，blob、text 等大字段，尽量少用。必须要用时，尽量与主业务表分离，减少对这类字段的检索和更新。  强制遵循规约 建库规约  【强制】数据库库名的命名规则必须遵循“见名知意”的原则,命名时的字符取值范围为：a~z，0~9 和 _（下画线，即库名规则为“数据库类型代码 &#43; (项目简称)&#43; 识别代码 &#43; 序号”。当库已项目拆分的时候增加项目简称，ad_zmb(广告系统自媒体宝业务正式库)  正例：这样包含了更多的业务信息，比如：
   广告系统业务生产库：ad、ad1、ad2； 广告系统业务开发库：ad_dev、ad_dev1、ad_dev2； 广告系统业务测试库：ad_test、ad_test1、ad_test2； 只有一个数据库，则不加序号，否则末尾增加序号； 生产库不加识别代码，否则需要增加识别代码 dev或 test； 如果只作历史库，则只需要项目简称 &#43;h&#43; 序号: ad_h；    建表规约  【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。  说明：任何字段如果为非负数，必须是 unsigned。"/>

    <meta property="og:title" content="新榜mysql规约" />
<meta property="og:description" content="新榜mysql规约** 概要 想要发挥 MySQL 的最佳性能，需要遵循 3 个基本使用原则：
 首先是需要让 MySQL 回归存储的基本职能：MySQL 数据库只用于数据的存储，不进行数据的复杂计算，不承载业务逻辑，确保存储和计算分离； 其次是查询数据时，尽量单表查询，减少跨库查询和多表关联； 还有就是要杜绝大事务、大 SQL、大批量、大字段等一系列性能杀手。 • 大事务，运行步骤较多，涉及的表和字段较多，容易造成资源的争抢，甚至形成死锁。一旦事务回滚，会导致资源占用时间过长。 • 大 SQL，复杂的 SQL 意味着过多的表的关联，MySQL 数据库处理关联超过 3 张表以上的 SQL 时，占用资源多，性能低下。 • 大批量，意味着多条 SQL 一次性执行完成，必须确保进行充分的测试，并且在业务低峰时段或者非业务时段执行。 • 大字段，blob、text 等大字段，尽量少用。必须要用时，尽量与主业务表分离，减少对这类字段的检索和更新。  强制遵循规约 建库规约  【强制】数据库库名的命名规则必须遵循“见名知意”的原则,命名时的字符取值范围为：a~z，0~9 和 _（下画线，即库名规则为“数据库类型代码 &#43; (项目简称)&#43; 识别代码 &#43; 序号”。当库已项目拆分的时候增加项目简称，ad_zmb(广告系统自媒体宝业务正式库)  正例：这样包含了更多的业务信息，比如：
   广告系统业务生产库：ad、ad1、ad2； 广告系统业务开发库：ad_dev、ad_dev1、ad_dev2； 广告系统业务测试库：ad_test、ad_test1、ad_test2； 只有一个数据库，则不加序号，否则末尾增加序号； 生产库不加识别代码，否则需要增加识别代码 dev或 test； 如果只作历史库，则只需要项目简称 &#43;h&#43; 序号: ad_h；    建表规约  【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。  说明：任何字段如果为非负数，必须是 unsigned。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yuyou80.github.io/posts/%E6%96%B0%E6%A6%9Cmysql%E8%A7%84%E7%BA%A6-/" /><meta property="article:section" content="posts" />





  </head>
  <body>
    <header class="app-header">
      <a href="https://yuyou80.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>有度规约</h1>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/">Home</a>
             - 
          
          <a class="app-header-menu-item" href="/tags/">Tags</a>
             - 
          
          <a class="app-header-menu-item" href="/about/">About</a>
      </nav>
      <p>newrank</p>
      <div class="app-header-social">
        
          <a href="https://github.com/gohugoio" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>Github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg>
          </a>
        
          <a href="https://twitter.com/gohugoio" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <title>Twitter</title>
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">新榜mysql规约</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jan 1, 0001
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          9 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://yuyou80.github.io/tags/mysql/">mysql</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h1 id="新榜mysql规约">新榜mysql规约**</h1>
<h2 id="概要">概要</h2>
<p><strong>想要发挥 MySQL 的最佳性能，需要遵循 3 个基本使用原则：</strong></p>
<ol>
<li>首先是需要让 MySQL 回归存储的基本职能：MySQL 数据库只用于数据的存储，不进行数据的复杂计算，不承载业务逻辑，确保存储和计算分离；</li>
<li>其次是查询数据时，尽量单表查询，减少跨库查询和多表关联；</li>
<li>还有就是要杜绝大事务、大 SQL、大批量、大字段等一系列性能杀手。
• 大事务，运行步骤较多，涉及的表和字段较多，容易造成资源的争抢，甚至形成死锁。一旦事务回滚，会导致资源占用时间过长。
• 大 SQL，复杂的 SQL 意味着过多的表的关联，MySQL 数据库处理关联超过 3 张表以上的 SQL 时，占用资源多，性能低下。
• 大批量，意味着多条 SQL 一次性执行完成，必须确保进行充分的测试，并且在业务低峰时段或者非业务时段执行。
• 大字段，blob、text 等大字段，尽量少用。必须要用时，尽量与主业务表分离，减少对这类字段的检索和更新。</li>
</ol>
<h2 id="强制遵循规约">强制遵循规约</h2>
<h3 id="建库规约">建库规约</h3>
<ol>
<li>【强制】数据库库名的命名规则必须遵循“见名知意”的原则,命名时的字符取值范围为：a~z，0~9 和 _（下画线，即库名规则为“数据库类型代码 + (项目简称)+ 识别代码 + 序号”。当库已项目拆分的时候增加项目简称，ad_zmb(广告系统自媒体宝业务正式库)</li>
</ol>
<p>正例：这样包含了更多的业务信息，比如：</p>
<ul>
<li>
<ul>
<li>广告系统业务生产库：ad、ad1、ad2；</li>
<li>广告系统业务开发库：ad_dev、ad_dev1、ad_dev2；</li>
<li>广告系统业务测试库：ad_test、ad_test1、ad_test2；</li>
<li>只有一个数据库，则不加序号，否则末尾增加序号；</li>
<li>生产库不加识别代码，否则需要增加识别代码 dev或 test；</li>
<li>如果只作历史库，则只需要项目简称 +h+ 序号: ad_h；</li>
</ul>
</li>
</ul>
<h3 id="建表规约">建表规约</h3>
<ol>
<li>【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。</li>
</ol>
<p>说明：任何字段如果为非负数，必须是 unsigned。</p>
<p>注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在<!-- raw HTML omitted -->设置从 is_xxx到 Xxx 的映射关系。数      据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含义与取值范围。</p>
<p>正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</p>
<ol>
<li>【强制】单表仅使用 a~z、_；分表名称为“表名_编号（数字/日期【如果表示年月需要连续】）”；禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</li>
</ol>
<p>说明：MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、字段名，都不允许      出现任何大写字母，避免节外生枝。</p>
<p>正例：ad_indent，rdc_config，level3_name，weixin_user_year_2020、weixin_user_20201211</p>
<p>反例：AdIndent，rdcConfig，level_3_name，weixin_user_2020_12_11</p>
<ol>
<li>【强制】表名不使用复数名词。</li>
</ol>
<p>说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。</p>
<p>正例：weixin_data_update_by_hour</p>
<p>反例：weixin_data_update_by_hours</p>
<ol>
<li>
<p>【强制】禁用特定保留字，如 desc、range、match、delayeds、select、delete、turncate 等，建议常用字段命名参考推荐规约第20条,<a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html#keywords-8-0-detailed-S">请参考 MySQL 官方保留字</a>。</p>
</li>
<li>
<p>【强制】小数类型为 decimal（定点数），禁止使用 float 和 double。</p>
</li>
</ol>
<p>说明：在存储的时候，float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的</p>
<p>结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。</p>
<ol>
<li>【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</li>
</ol>
<p>说明：如果存在长度相同的订单号，唯一编号等情况下使用定长字符串类型。</p>
<ol>
<li>【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长</li>
</ol>
<p>度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索</p>
<p>引效率。</p>
<p>说明：text的最大存储字节长度65535，已utf8做编码集为例可以存储21845个汉字。</p>
<ol>
<li>【强制】表必备三字段：id, gmt_create, gmt_modified。</li>
</ol>
<p>说明：其中 id 必为主键，类型为 (bigint/int) unsigned、单表时自增、步长为 1。gmt_create, gmt_modified</p>
<p>的类型均为 datetime 类型,方便后续查看gmt_create, gmt_modified需要置于表尾。</p>
<ol>
<li>【强制】常见业务表命名规范临时表 xxx_tmp；备份表xxx_bak；字典表xxx_dic；日志表xxx_log。</li>
</ol>
<p>说明：weixin_data_for_cal_by_day_tmp/sys_user_right_bak/ad_conifg_dic/ad_business_log</p>
<ol>
<li>【强制】禁用 ENUM、SET 类型。</li>
</ol>
<p>说明：兼容性不好，性能差。使用 TINYINT，在 COMMENT 信息中标明被枚举的含义。<code>is_disable</code> TINYINT UNSIGNED DEFAULT &lsquo;0&rsquo; COMMENT &lsquo;是否可用[0:启用;1:禁用;2:异常]’。</p>
<ol>
<li>【强制】针对表必须添加 comment 注释，每个字段需要添加相应的备注，修饰状态字段需要需按照规范进行备注。</li>
</ol>
<p>说明：使用规范化的标准定义状态备注便于我们进行状态的跟进。</p>
<p>正例：订单表的状态字段：indent_status ：   订单状态[0:待支付;1:已支付;2:已发货;3:已签收]</p>
<ol>
<li>【强制】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。</li>
</ol>
<h3 id="索引规约">索引规约</h3>
<ol>
<li>【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。</li>
</ol>
<p>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据<a href="https://baike.baidu.com/item/%E5%A2%A8%E8%8F%B2%E5%AE%9A%E5%BE%8B/746284?fr=aladdin">墨菲定律</a>，必然有脏数据产生。</p>
<ol>
<li>【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。</li>
</ol>
<p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</p>
<ol>
<li>【强制】防止因字段类型和编码集不同造成的隐式转换，导致索引失效。</li>
</ol>
<p>说明：编码集的不同常会导致关联表查询的时候索引失效，在针对字符串类型上建立索引的如果没有特殊字符（需要占用4字节字符）我们推荐使用utf8编码集（排序集：utf8_general_ci），如果是全英文或数字等占用1字节的字符也推荐使用latin1；但仍需要注意的是，不同表的相同字段需要使用统一的编码集。</p>
<ol>
<li>【强制】索引命名规范：主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。</li>
</ol>
<p>说明：索引命名格式，主要为了区分哪些对象是索引</p>
<p>前缀_表名（或缩写）_字段名（或缩写）；</p>
<p>主键必须使用前缀“pk_”；</p>
<p>UNIQUE 约束必须使用前缀“uk_”；</p>
<p>普通索引必须使用前缀“idx_”。</p>
<h3 id="sql-语句规约">SQL 语句规约</h3>
<ol>
<li>【强制】不要使用 count(列名)或 count(常量)来替代 count(<em>)，count(</em>)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。</li>
</ol>
<p>说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p>
<ol>
<li>
<p>【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</p>
</li>
<li>
<p>【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。</p>
</li>
</ol>
<p>正例：使用如下方式来避免 sum 的 NPE 问题：SELECT IFNULL(SUM(column), 0) FROM table;</p>
<ol>
<li>【强制】使用 ISNULL()来判断是否为 NULL 值。</li>
</ol>
<p>说明：NULL 与任何值的直接比较都为 NULL。</p>
<p>1） NULL&lt;&gt;NULL 的返回结果是 NULL，而不是 false。</p>
<p>2） NULL=NULL 的返回结果是 NULL，而不是 true。</p>
<p>3） NULL&lt;&gt;1 的返回结果是 NULL，而不是 true。</p>
<ol>
<li>
<p>【强制】代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。</p>
</li>
<li>
<p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p>
</li>
</ol>
<p>说明：以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中           的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分           布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p>
<ol>
<li>
<p>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p>
</li>
<li>
<p>【强制】数据订正（特别是删除、修改记录操作）时，要先 select，避免出现误删除，确认无误才能执行更新语句。</p>
</li>
<li>
<p>【强制】涉及多张表的增删改查sql，上线前一定要去生产库查看sql的执行计划，explain/desc sql, 以便于及时优化。</p>
</li>
</ol>
<h2 id="参考推荐规约">参考推荐规约：</h2>
<ol>
<li>【推荐】业务表名代表用途、内容：子系统简称_业务含义_后缀。</li>
</ol>
<p>正例： zmb_case/ zmb_indent_2020/zmb_case_bak</p>
<ol>
<li>
<p>【推荐】库名与应用名称尽量一致。</p>
</li>
<li>
<p>【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：</p>
</li>
<li>
<ol>
<li>不是频繁修改的字段。</li>
<li>不是 varchar 超长字段，更不能是 text 字段。</li>
<li>不是唯一索引的字段。</li>
</ol>
</li>
</ol>
<p>正例：商品类目名称使用频率高，字段长度短，名称基本一不变，可在相关联的表中冗余存储类目名</p>
<p>称，避免关联查询。</p>
<ol>
<li>【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。</li>
</ol>
<p>说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p>
<ol>
<li>【推荐】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</li>
</ol>
<p>正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1614934132639-17cb2156-7691-4b1f-a089-d2b963c72d29.png" alt="image"></p>
<ol>
<li>【推荐】尽量避免三个表的 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。</li>
</ol>
<p>说明：即使双表 join 也要注意表索引、SQL 性能。</p>
<ol>
<li>【推荐】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</li>
</ol>
<p>说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
<ol>
<li>【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。</li>
</ol>
<p>正例：where a=? and b=? order by c; 索引：a_b_c</p>
<p>反例：索引如果存在范围查询，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b; 索引 a_b 无法排序。</p>
<ol>
<li>【推荐】利用覆盖索引来进行查询操作，避免回表。</li>
</ol>
<p>说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。</p>
<p>正例：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用 explain 的结果，extra 列会出现：using index。</p>
<ol>
<li>【推荐】利用延迟关联或者子查询优化超多分页场景。</li>
</ol>
<p>说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL改写。</p>
<p>正例：先快速定位需要获取的 id 段，然后再关联： SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</p>
<ol>
<li>【推荐】SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是consts 最好。</li>
</ol>
<p>说明：</p>
<p>1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。</p>
<p>2） ref 指的是使用普通的索引（normal index）。</p>
<p>3） range 对索引进行范围检索。</p>
<p>反例：explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range还低，与全表扫描是小巫见大巫。</p>
<ol>
<li>【推荐】建组合索引的时候，区分度最高的在最左边。</li>
</ol>
<p>正例：如果 where a=? and b=? ，如果 a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。</p>
<p>说明：存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如：where c&gt;? and d=? 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即索引 idx_d_c。</p>
<ol>
<li>
<p>【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。</p>
</li>
<li>
<p>【推荐】如果有国际化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。</p>
</li>
</ol>
<p>说明：</p>
<p>​     SELECT LENGTH(&ldquo;轻松工作&rdquo;)； 返回为 12</p>
<p>SELECT CHARACTER_LENGTH(&ldquo;轻松工作&rdquo;)； 返回为 4</p>
<p>如果需要存储表情，那么选择 utf8mb4 来进行存储，注意它与 utf-8 编码的区别。</p>
<ol>
<li>【推荐】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但TRUNCATE 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。</li>
</ol>
<p>说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p>
<ol>
<li>【推荐】创建索引时避免有如下极端误解：</li>
</ol>
<p>1） 宁滥勿缺。认为一个查询就需要建一个索引。</p>
<p>2） 宁缺勿滥。认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度。</p>
<p>3） 抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</p>
<p>\17.  【推荐】针对IP存储处理：</p>
<p>一般使用 Char(15) 进行存储，但是当进行查找和统计时，字符类型不是很高效。</p>
<p>MySQL 数据库内置了两个 IP 相关的函数 INET_ATON()、INET_NTOA()，可以实现 IP 地址和整数的项目转换。</p>
<p>因此，我们使用 INT UNSIGNED（占用 4 个字节）存储 IP，非 Char(15)。占 15 个字符。</p>
<pre><code>下图所示，IP：192.168.0.1 与整数之间的转换。
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618467801042-69a9ecca-34e1-438b-a2e0-9da856a9bcad.png" alt="image"><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618467829699-a677a9e1-371b-4428-9fc9-1e5453df160f.png" alt="image"></p>
<p>将 IP 的存储从字符型转换成整形，转化后数字是连续的，提高了查询性能，使查询更快，占用空间更小。</p>
<p>18.【推荐】针对TIMESTAMP 的处理</p>
<p>MySQL 内置的函数(FROM_UNIXTIME()，UNIX_TIMESTAMP())，可以将日期转化为数字，用 INT UNSIGNED 存储日期和时间。</p>
<p>下图示所示，时间 2021-04-15 10:30:19 与整数之间的转换，转化后数字是连续的，占用空间更小，并且可以使用索引提升查询性能</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618468498492-353d35b5-571a-4c67-b7f4-7753c033297c.png" alt="image"><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618468532148-d23d32af-67ff-4513-a251-c39ebaed4331.png" alt="image"></p>
<p>19.【推荐】指定整型的正确长度</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1610547951926-927a5976-f901-42fb-82c2-9bb0ed63b236.png" alt="image"></p>
<p>如上图所示mysql提供的整型字段中对应字节数和有符合和无符号的参考表；</p>
<p>建立表中需要指定正确的长度(包含符号位)方便进行理解 tinyint(4),smallint(6),mediumint(8),int(11),bigint(20);</p>
<p>**int(3)/int(5) 区别 :**如下图所示。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1610547986564-03788415-6e44-4f8a-96c2-e17291741094.png" alt="image"></p>
<ul>
<li>
<p>正常显示没有区别。</p>
</li>
<li>
<p>3 和 5 仅是最小显示宽度而已。</p>
</li>
<li>
<p>有 zerofill 等扩展属性时则显示有区别。</p>
</li>
</ul>
<p>20.【推荐】推荐常用字段名方式</p>
<ul>
<li>memo  备注</li>
<li>order_num 订单号</li>
<li>is_deleted 是否删除</li>
<li></li>
</ul>
<h2 id="性能篇">性能篇</h2>
<h3 id="索引设计和工作原理">索引设计和工作原理</h3>
<p>先来看看索引设计和工作原理。想创建高性能索引，首先要了解什么是索引。维基百科对其定义：数据库索引是一种数据结构，它以额外的写入和存储空间为代价来提高数据库表上数据检索操作的速度。通俗来说，索引类似于书的目录，根据其中记录的页码可以快速找到所需的内容。</p>
<p>MySQL 官方对索引（Index）的定义是存储引擎用于快速查找记录的一种数据结构。</p>
<p>索引是物理数据页，数据库页大小（Page Size）决定了一个页可以存储多少个索引行，以及需要多少页来存储指定大小的索引。</p>
<ul>
<li>索引可以加快检索速度，但同时也降低索引列插入、删除、更新的速度，索引维护需要代价。</li>
<li>索引涉及的理论知识有二分查找法、哈希表及 B+Tree。</li>
</ul>
<h4 id="二分查找法">二分查找法</h4>
<p>二分查找法也叫作折半查找法，它是在有序数组中查找指定数据的搜索算法。<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/10628618?fromtitle=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95&amp;fromid=8283141&amp;fr=aladdin">二分查找法的定义</a>参考百度百科。它的优点是等值查询、范围查询性能优秀，缺点是更新数据、新增数据、删除数据维护成本高。（二分查找是索引实现的理论基础）</p>
<h4 id="索引原理">索引原理</h4>
<p>大家都知道数据库查询是数据库的核心功能，而索引又是作为加速查询的重要技术手段。对于索引数据结构的选择其本质是贴合当前数据读写的硬件环境选择一个优秀的数据结构进行数据存储及遍历，在数据库中大部分索引都是通过 B+Tree 来实现的。当然也涉及其他数据结构，在 MySQL 中除了 B+Tree 索引外我们还需要关注下 Hash 索引。</p>
<p>接下来我们对 Hash 索引、B+Tree 索引逐一展开学习。因为后续大部分内容都是讲 B 树的，为了让 B 树的内容更连贯，这里先讲 Hash 索引。</p>
<h4 id="hash-索引">Hash 索引</h4>
<p>哈希表是数据库中哈希索引的基础，是根据键值 &lt;key,value&gt; 存储数据的结构。简单说，哈希表是使用哈希函数将索引列计算到桶或槽的数组，实际存储是根据哈希函数将 key 换算成确定的存储位置，并将 value 存放到该数组位置上。访问时，只需要输入待查找的 key，即可通过哈希函数计算得出确定的存储位置并读取数据。</p>
<p>如下图所示，姓名作为 key，通过哈希函数对姓名字段数据进行计算，得到哈希码并存放到桶或槽的数组中，同时存放指向真实数据行的指针作为 value，形成哈希表。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1610549109576-137af26c-36e4-4aa2-aaca-0eedbbb5112c.png" alt="image"></p>
<p>接下来我们从哈希索引如何实现、Hash 碰撞处理、MySQL 如何使用 Hash，三个方面学习哈希索引。</p>
<p>首先讲解哈希索引是如何实现的？数据库中哈希索引是基于哈希表实现的，对于哈希索引列的数据通过 Hash 算法计算，得到对应索引列的哈希码形成哈希表，由哈希码及哈希码指向的真实数据行的指针组成了哈希索引。哈希索引的应用场景是只在对哈希索引列的等值查询才有效。</p>
<p>如下图所示，根据表中的 name 字段构建 Hash 索引，通过 Hash 算法对每一行 name 字段的数据进行计算，得出 Hash 码。由 Hash 码及 Hash 码指向真实数据行的指针组成了哈希索引。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1610549136150-a439e304-37a7-416e-bb3d-cf96dac784b0.png" alt="image"></p>
<p>因为哈希索引只存储哈希值和行指针，不存储实际字段值，所以其结构紧凑，查询速度也非常快，在无哈希冲突的场景下访问哈希索引一次即可命中。但是哈希索引只适用于等值查询，包括 =、IN()、&lt;=&gt; （安全等于， select null &lt;=&gt; null 和 select null=null 是不一样的结果) ，不支持范围查询。</p>
<p>另外，哈希索引的性能跟哈希冲突数量成反比，哈希冲突越多其维护代价越大性能越低。</p>
<p>接下来我们看看 Hash 碰撞如何处理？Hash 碰撞是指不同索引列值计算出相同的哈希码，如上图所示， 表中 name 字段为 John Smith 和 Sandra Dee 两个不同值根据 Hash 算法计算出来的哈希码都是 152，这就表示出现了 Hash 碰撞。 对于 Hash 碰撞通用的处理方法是使用链表，将 Hash 冲突碰撞的元素形成一个链表，发生冲突时在链表上进行二次遍历找到数据。</p>
<ul>
<li>
<p>Hash 碰撞跟选择的 Hash 算法有关系，为了减少 Hash 碰撞的概率，优先选择避免 Hash 冲突的 Hash 算法，例如，使用 Percona Server 的函数 FNV64() ，其哈希值为 64 位，出现 Hash 冲突的概率要比 CRC32 小很多。</p>
</li>
<li>
<p>其次是考虑性能，优先选择数字类型的 Hash 算法，因为字符串类型的 Hash 算法不仅浪费空间而且不方便进行比较。</p>
</li>
</ul>
<p>常见的 CRC32、SHA1 和 MD5 Hash 函数生成的返回值如下图所示。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1610549423620-a76bf003-00a1-40a9-b57e-5289300acf8d.png" alt="image.png"></p>
<p>综合建议 Hash 算法使用优先级为：FNV64 &gt; CRC32 （大数据量下 Hash 冲突概率较大）&gt; MD5 &gt; SHA1。</p>
<p>最后再看看，MySQL 中如何使用 Hash 索引？在 MySQL 中主要是分为 Memory 存储引擎原生支持的 Hash 索引 、InnoDB 自适应哈希索引及 NDB 集群的哈希索引3类。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1610549459897-56b171c9-5212-478e-b155-e90071c3d41b.png" alt="image"></p>
<p>Memory 存储引擎原生支持的 Hash 索引，如上图所示，Memory 存储引擎创建表时即可原生显式创建并使用 Hash 索引。</p>
<p>相比 InnoDB，虽然不能原生显示创建 Hash 索引，但是可以伪造哈希索引来加速定值查询的性能。例如为超长文本（如网站 URL）进行 Hash 计算后的字段 url_hash 创建 B+Tree 索引，获得 Hash 索引的功能。</p>
<p>关于哈希索引，InnoDB 提供了 InnoDB 自适应哈希索引的强大功能，接下来重点描述 InnoDB 自适应哈希索引。</p>
<p>InnoDB 自适应哈希索引是为了提升查询效率，InnoDB 存储引擎会监控表上各个索引页的查询，当 InnoDB 注意到某些索引值访问非常频繁时，会在内存中基于 B+Tree 索引再创建一个哈希索引，使得内存中的 B+Tree 索引具备哈希索引的功能，即能够快速定值访问频繁访问的索引页。</p>
<h4 id="btree-索引">B+Tree 索引</h4>
<p>在数据库中大部分索引都是通过 B+Tree 来实现的。 对于 B+Tree 具体的定义可以参考《数据结构》等相关书籍。 在 MySQL 数据库中讨论索引时，如果没有明确指定类型，则默认是指使用 B+Tree 数据结构进行存储，其说法等价于 B+Tree、B-Tree、BTREE（看到创建索引语句为 BTREE 也不要惊讶，等同于 B+Tree）。</p>
<p>如下图所示为一个简单的、标准的 B+tree，每个节点有 K 个键值和 K+1 个指针。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1610549664971-b56218ec-4817-4e68-be8e-ff8cec93d458.png" alt="image"></p>
<p>对于 MySQL 存储引擎而言，其实际使用的 B+Tree 索引是为了满足数据读写性能，以及适配磁盘访问模式优化后的数据结构，每一个叶子节点都包含指向下一个叶子节点的指针。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1610549809051-1757e37e-c51d-4ad2-9f54-35d52aa1c832.png" alt="image"></p>
<p>在 MySQL 中，索引是在存储引擎层而非服务器层实现的，所以不同存储引擎层支持的索引类型可以不同。例如，虽然 MyISAM 和 InnoDB 的索引都是使用 B+Tree 实现的，但是其实际数据存储结构有不少差异。下图中 B+Tree 示例一共2层，图中每个页面都已经被随机编号（编号可以认定为页面号），其中页面号为 20 的页面是 B+Tree 的根页面（根页面通常是存放在内存中的），根页面存储了 &lt;key+pageno&gt;，pageno 是指向具体叶子节点的页面号。其他页面都是叶子节点，存放了具体的数据 &lt;key+data&gt;。</p>
<p>B+Tree 索引能够快速访问数据，就是因为存储引擎可以不再需要通过全表扫描来获取数据，而是从索引的根结点（通常在内存中）开始进行二分查找，根节点的槽中都存放了指向子节点的指针，存储引擎根据这些指针能够快速遍历数据。例如，通过页面号为 20 的根节点可以快速得知 Key&lt;10 的数据在 pageno 33 的页面，key在 [10,16) 范围的数据在 pageno 56 的页面。</p>
<p>叶子节点存放的 &lt;key+data&gt; ，对于真正要存放哪些数据还得取决于该 B+Tree 是聚簇索引（Clustered Index）还是辅助索引（Secondary Index）。</p>
<h4 id="聚簇索引和辅助索引">聚簇索引和辅助索引</h4>
<p>聚簇索引是一种数据存储方式，它表示表中的数据按照主键顺序存储，是索引组织表。InnoDB 的聚簇索引就是按照主键顺序构建 B+Tree，B+Tree 的叶子节点就是行记录，数据行和主键值紧凑地存储在一起。 这也意味着 InnoDB 的主键索引就是数据表本身，它按主键顺序存放了整张表的数据。</p>
<p>而 InnoDB 辅助索引（也叫作二级索引）只是根据索引列构建 B+Tree，但在 B+Tree 的每一行都存了主键信息，加速回表操作。</p>
<p>聚簇索引占用的空间就是整个表数据量的大小，而二级索引会比聚簇索引小很多， 通常创建辅助索引就是为了提升查询效率</p>
<p>InnoDB 只能创建一个聚簇索引（假想下如果能支持多个聚簇索引，那就意味着一张表按不同排序规则冗余存储多份全表数据了），但可以创建多个辅助索引。</p>
<p>相比索引组织表，还有一种堆表类型，堆表是根据数据写入的顺序直接存储在磁盘上的。对于堆表而言，其主键和辅助索引唯一的区别就是键值是否唯一，两者都是根据索引列排序构建 B+Tree 的，在每个叶子节点加上指向堆表的行指针（row data pointer） 。堆表在各类数据库中也被广泛使用，MyISAM 存储引擎的表就是堆表。</p>
<h4 id="索引类型">索引类型</h4>
<p>了解完原理，接下来看看索引类型。在前面重点强调过：MySQL 中索引是在存储引擎层而非服务器层实现的，所以不同存储引擎层支持的索引类型可以不同。在 MySQL 中不同存储引擎间支持的常见索引类型有：哈希索引（Memory/InnoDB adaptive Hash index/NDB）、 B+Tree 索引（MyISAM/InnoDB）、全文索引（MyISAM/InnoDB）、空间索引（MyISAM R-Tree）、分形树索引（TokuDB Fractal Tree Index），如下表所示。</p>
<p>MySQL InnoDB 存储引擎支持的常见索引类型。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1610549913033-58666f06-3232-48a0-b55f-7f425b302d19.png" alt="image"></p>
<p>在 MySQL InnoDB 中索引通常可以分为两大类：主键索引（即聚簇索引）和辅助索引（非聚簇索引） 。</p>
<p>对于没有指定主键的表，InnoDB 会自己选择合适字段为主键，其选择顺序如下：</p>
<ol>
<li>
<p>显式主键；</p>
</li>
<li>
<p>第一个唯一索引（要求唯一索引所有列都非 NULL）；</p>
</li>
<li>
<p>内置的 6 字节 ROWID。</p>
</li>
</ol>
<p>建议使⽤ UNSIGNED 自增列显示创建主键？</p>
<ul>
<li>
<p>根据索引列个数和功能描述不同索引也可以分为：联合索引和覆盖索引。</p>
</li>
<li>
<p>联合索引是指在多个字段联合组建索引的。</p>
</li>
<li>
<p>当通过索引即可查询到所有记录，不需要回表到聚簇索引时，这类索引也叫作覆盖索引。</p>
</li>
</ul>
<p>主键查询是天然的覆盖索引，联合索引可以是覆盖索引。</p>
<p>那么如何看 SQL 语句是否使用到覆盖索引了呢？</p>
<p>通常在查看执行计划时， Extra 列为 Using index 则表示优化器使用了覆盖索引。</p>
<p>我们通常建议优先考虑使用覆盖索引，这是因为如果 SQL 需要查询辅助索引中不包含的数据列时，就需要先通过辅助索引查找到主键值，然后再回表通过主键查询到其他数据列（即回表查询），需要查询两次。而覆盖索引能从索引中直接获取查询需要的所有数据，从⽽避免回表进行二次查找，节省IO，效率较⾼。</p>
<p>例如，SELECT email，uid FROM user_email WHERE uid=xx，如果 uid 不是主键，那可以将索引添加为 index(uid，email)，以获得查询性能提升。</p>
<h3 id="explian查看执行计划">explian查看执行计划</h3>
<h4 id="explian参数解析">explian参数解析</h4>
<p>创建索引后通过查看执行 SQL 语句的执行计划即可知道 SQL 语句是否走索引。执行计划重点关注跟索引相关的关键项，有 type、possible_keys、key、key_len、rows、ref、Extra 等。</p>
<p>其中，<strong>possible_keys</strong> 表示查询可能使用的索引，<strong>key</strong>表示真正实际使用的索引，<strong>key_len</strong> 表示使用索引字段的长度，<strong>rows</strong>表示扫描出的行数(估算的行数)。</p>
<p>另外执行计划中 <strong>Extra</strong> 选项也值得关注，例如 Extra 显示 use index 时就表示该索引是覆盖索引，通常性能排序的结果是 usd index &gt; use where &gt; use filsort。</p>
<p>当索引选择组合索引时，通过计算 <strong>key_len</strong> 来了解有效索引长度对索引优化也是非常重要的，接下来重点讲解 key_len 计算规则。</p>
<p><strong>key_len</strong> 表示得到结果集所使用的选择索引的长度[字节数]，不包括 order by，也就是说如果 order by 也使用了索引则 key_len 不计算在内。</p>
<h4 id="key_len的计算">key_len的计算</h4>
<p>key_len 计算规则从两个方面考虑，一方面是索引字段的数据类型，另一方面是表、字段所使用的字符集。</p>
<p>\1. 索引字段的数据类型，根据索引字段的定义可以分为变长和定长两种数据类型：</p>
<p>索引字段为定长数据类型，比如 char、int、datetime，需要有是否为空的标记，这个标记需要占用 1 个字节；</p>
<p>对于变长数据类型，比如 Varchar，除了是否为空的标记外，还需要有长度信息，需要占用 2 个字节；（备注：当字段定义为非空的时候，是否为空的标记将不占用字节）。</p>
<p>\2. 表所使用的字符集，不同的字符集计算的 key_len 不一样，例如，GBK 编码的是一个占用 2 个字节大小的字符，UTF8 编码的是一个占用 3 个字节大小的字符。</p>
<p>举例说明：在四类字段上创建索引后的 key_len 如何计算呢？</p>
<p>Varchar(10) 变长字段且允许 NULL:10*(Character Set：utf8=3，gbk=2，latin1=1)+1（标记是否为 NULL 需要 1 个字节）+ 2（变长字段存储长度信息需要 2 个字节）。</p>
<p>Varchar(10) 变长字段且不允许 NULL:10*(Character Set：utf8=3，gbk=2，latin1=1)+2（变长字段存储长度信息需要2个字节），非空不再需要占用字节来标记是否为空。</p>
<p>Char(10) 固定字段且允许 NULL:10*(Character Set：utf8=3，gbk=2，latin1=1)+1（标记是否为 NULL 需要 1 个字节）。</p>
<p>Char(10) 固定字段且不允许 NULL:10*(Character Set：utf8=3，gbk=2，latin1=1)，非空不再需要占用字节来标记是否为空。</p>
<h4 id="查看sql执行计划中的type解析"><strong>查看sql执行计划中的type解析</strong></h4>
<ol>
<li>对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。</li>
</ol>
<p>常用的类型有： **ALL、index、range、 ref、eq_ref、const、system、**<strong>NULL（从左到右，性能从差到好）</strong></p>
<ul>
<li><strong>ALL</strong>：Full Table Scan， MySQL将遍历全表以找到匹配的行</li>
<li><strong>index</strong>: Full Index Scan，index与ALL区别为index类型只遍历索引树</li>
<li><strong>range</strong>:只检索给定范围的行，使用一个索引来选择行</li>
<li><strong>ref</strong>: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li>
<li><strong>eq_ref</strong>: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</li>
<li><strong>const</strong>、<strong>system</strong>: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system</li>
<li><strong>NULL</strong>: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</li>
</ul>
<h4 id="常见可能导致索引失效的原因和示例">常见<strong>可能导致索引失效的原因和示例</strong></h4>
<h5 id="常见可能导致索引失效的原因">常见可能导致索引失效的原因：</h5>
<ul>
<li>不满足最左前缀原则</li>
<li>范围索引列没有放在最后</li>
<li>使用了select *</li>
<li>索引列上有计算</li>
<li>索引列上使用了函数</li>
<li>字符类型没加引号</li>
<li>用is null和is not null没注意字段是否允许为空</li>
<li>like查询左边有%</li>
<li>使用or关键字时没有注意</li>
<li>编码集不同导致关联查询索引失效</li>
</ul>
<h5 id="索引失效示例">索引失效示例：</h5>
<p><strong>索引失效场景案例：</strong></p>
<p><strong>准备工作：</strong></p>
<p>查看当前数据库版本：</p>
<pre><code>#查看当前数据库版本
select version();
</code></pre><p>当前版本 5.7.9-log(以下场景按照我实际执行版本为例)</p>
<p>创建测试newrank_user表：</p>
<pre><code>CREATE TABLE `newrank_user` (
  `id` bigint UNSIGNED NOT NULL,
  `code` varchar(32) NOT NULL,
    `age` int NOT NULL,
    `name` varchar(32) NOT NULL,
  `rank` int NOT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_code_age_name` (`code`,`age`,`name`) USING BTREE,
  KEY `idx_rank` (`rank`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
</code></pre><p>插入几条数据：</p>
<pre><code>INSERT INTO `newrank_user`(`id`, `code`, `name`, `age`,`rank`) VALUES (1, '001', '张三', 20,7);
INSERT INTO `newrank_user`(`id`, `code`, `name`, `age`,`rank`) VALUES (2, '002', '李四', 23,8);
INSERT INTO `newrank_user`(`id`, `code`, `name`, `age`,`rank`) VALUES (3, '003', '王五', 25,8);
</code></pre><p>当前建立索引情况 idx_code_age_name( code , age , name )联合索引 和 idx_rank(rank)普通索引</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618315253364-42cfdb05-feb5-4f1e-8be9-24bdaf2032cd.png" alt="image.png"></p>
<p><strong>不满足最左前缀原则测试情况</strong></p>
<p><strong>第一种情况：</strong></p>
<p>where 条件后的字段包含了联合索引的所有索引字段，并且顺序是按照： code 、 age 、name 。</p>
<pre><code>explain select * from newrank_user where code = '001' and age = 20 and name = '张三';
</code></pre><p>对应执行计划：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618315579228-d111303a-793f-4749-b780-095e01977059.png" alt="image.png"></p>
<p>结果：</p>
<p>从图中标红的地方可以看出已经走了联合索引idx_code_name_age，并且索引的长度是 264， 264 = 32 * 4 + 2 + 32 * 4 + 2 + 4 ，索引是使用充分的，索引使用效率最佳。</p>
<p><strong>第二种情况：</strong></p>
<p>where 条件后的字段包含了联合索引的所有索引字段，顺序是不按照： code 、 age 、name。</p>
<pre><code>explain select * from newrank_user where code = '001' and name = '张三' and age = 20 ;
</code></pre><p>对应执行计划：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618315818969-9d2b7259-6b09-41a1-98da-feffb26fd2ad.png" alt="image.png"></p>
<p>从上图中看出执行结果跟第一种情况一样。</p>
<p>注意：这种情况比较特殊，在查询之前mysql会自动优化顺序。</p>
<p><strong>第三种情况：</strong></p>
<p>where 条件后的字段包含了联合索引中的： code 字段</p>
<pre><code>explain  select * from newrank_user where code='001';
</code></pre><p>执行计划：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618315939829-2315024c-06c5-445a-8454-c6601e70a0d1.png" alt="image.png"></p>
<p>从上图看出也走了索引，但是索引长度有所变化，现在变成了 130 ， 130 = 32*4 + 2 ，只用到了一个索引字段code，索引使用不充分。</p>
<p><strong>第四种情况：</strong></p>
<p>where 条件后的字段包含了联合索引中的： age 字段</p>
<pre><code>explain  select * from newrank_user where age= 20;
</code></pre><p>执行计划：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618316037218-d2a80fda-d784-42e1-832c-ef119d5f93fb.png" alt="image.png"></p>
<p>从上图中看变成了全表扫描，所有的索引都失效了。</p>
<p><strong>第五种情况：</strong></p>
<p>where 条件后的字段包含了联合索引中的： name 字段</p>
<pre><code>explain  select * from newrank_user where name = '张三';
</code></pre><p>执行计划：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618316202413-cd5b9670-313d-4719-900e-5cccf5944a7e.png" alt="image.png"></p>
<p>从上图中看变成了全表扫描，所有的索引都失效了。</p>
<p><strong>第六种情况：</strong></p>
<p>where 条件后的字段包含了联合索引中的： code 和 age 字段</p>
<pre><code>explain select * from newrank_user where code = '001' and age = 20;
</code></pre><p>执行计划：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618316292685-7212ced9-778e-45a4-a463-f7564aad4ff6.png" alt="image.png"></p>
<p>从上图中看出还是走了索引，但是索引长度变成了： 134， 96 = 32*4 + 2 + 4 ，只用到了两个索引字段code和age，索引使用也不充分。</p>
<p><strong>第七种情况：</strong></p>
<p>where 条件后的字段包含了联合索引中的： code 和 name 字段</p>
<pre><code>explain select * from newrank_user where code = '001' and name = '张三';
</code></pre><p>执行计划：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618316427191-363a2bbb-2b0f-47d6-b615-b5d5f29d8c81.png" alt="image.png"></p>
<p>从上图中看出走的索引长度跟第三种情况一样，长度也是 130 。也就是说只用到了一个索引字段 code ，而 age 字段的索引失效了。</p>
<p><strong>第八种情况：</strong></p>
<p>where 条件后的字段包含了联合索引中的： age 和 name 字段</p>
<pre><code>explain select * from newrank_user where age = 20 and name = '张三' ;
</code></pre><p>执行计划：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618316589852-d7507340-521a-408b-ae3e-82dd7ebc967c.png" alt="image.png"></p>
<p>从上图中看出变成了全表扫描，所有的索引都失效了。</p>
<p><strong>小结：</strong></p>
<ol>
<li>满足最左前缀的场景：<code>code</code>，<code>code、age</code>，<code>code、age、name</code>。</li>
<li>包含：<code>code</code>、<code>age</code>、<code>name</code>全索引字段的情况比较特殊，这三个字段作为查询条件的任意一种排序都OK，最终mysql会优化成最左前缀的顺序。</li>
<li>如果中间出现断层，如：<code>code、name</code>，只会走第一个索引code，从断层后的索引都会失效。</li>
<li>其他的场景：<code>age</code>，<code>name</code>，<code>age,name</code>索引都会失效。</li>
</ol>
<p><strong>范围索引列没有放在最后</strong></p>
<p><code>where</code>条件后的字段<code>age</code>用了大于等于，具体sql如下：</p>
<pre><code>explain select * from newrank_user where  code='001' and age&gt;18 and name='张三' ;
</code></pre><p>执行计划：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618317082971-c8fc7e10-8809-406e-b175-1dc3836a795e.png" alt="image.png"></p>
<p>从上图中看出索引长度变成：134<code>= 32*4 + 2 + 4</code>，只用到了两个索引字段<code>code</code>和<code>age</code>，而<code>name</code>字段的索引失效了。</p>
<p>如果范围查询的语句放到最后：</p>
<pre><code>explain select * from newrank_user where  code='001'  and name='张三' and age&gt;18 ;
</code></pre><p>结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618317082971-c8fc7e10-8809-406e-b175-1dc3836a795e.png" alt="image.png"></p>
<p>索引长度还是：134？</p>
<p>**这是一个非常典型的错误，**范围查询放最后是指创建联合索引的字段顺序，现在的顺序是：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618315253364-42cfdb05-feb5-4f1e-8be9-24bdaf2032cd.png" alt="image.png"></p>
<p>调整一下把索引字段name和age的顺序调整一下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618317299622-b050fbeb-dbd0-4c27-af59-5fd5c56544dc.png" alt="image.png"></p>
<p>再执行上面的sql，结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618317382775-97ee41a8-c259-4307-921e-7b9b235d3e40.png" alt="image.png"></p>
<p>从上图中看出索引长度变成：<code>264</code>，索引使用充分了。</p>
<p>回过头再执行刚开始的那条sql：</p>
<pre><code>explain select * from newrank_user where  code='001' and age&gt;18 and name='张三' ;
</code></pre><p>结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618317382775-97ee41a8-c259-4307-921e-7b9b235d3e40.png" alt="image.png"></p>
<p>索引长度也是：<code>264</code>。</p>
<blockquote>
<p>★注意：范围查询放最后，指的是联合索引中的范围列放在最后，不是指where条件中的范围列放最后。如果联合索引中的范围列放在最后了，即使where条件中的范围列没放最后也能正常走到索引。”</p>
</blockquote>
<p><strong>使用了select *</strong></p>
<p>上述规约中中也明确说了，禁止使用select * ，这是为什么呢？</p>
<pre><code>explain select * from newrank_user
</code></pre><p>结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618316589852-d7507340-521a-408b-ae3e-82dd7ebc967c.png" alt="image.png"></p>
<p>从上图中看出走了全表扫描。</p>
<p>那么如果查询的是索引列：</p>
<pre><code>explain select code,age,name from newrank_user
</code></pre><p>结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618317652131-d0b77062-7c3e-402b-9a2c-d3427c4d6bbb.png" alt="image.png"></p>
<p>从图中可以看出这种情况走了全索引扫描，比全表扫描效率更高。</p>
<p>其实这里用到了：<code>覆盖索引</code>。</p>
<p>如果<code>select</code>的列都是索引列，则被称为<code>覆盖索引</code>。</p>
<p>如果<code>select</code>的列不只包含索引列，则需要<code>回表</code>，即回到表中再查询出其他列，效率相当更低一些。<code>select *</code> 大概率需要查询非索引列，需要<code>回表</code>，因此要少用。</p>
<p>当然，当前很多示例都使用了<code>select *</code> ，主要是我表中只有几条数据，为了方便演示，正常业务代码中是要杜绝这种写法的。</p>
<p><strong>索引列上有计算</strong></p>
<pre><code>explain select * from newrank_user where rank+1 =8;
</code></pre><p>执行计划：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618317809157-ab35d4c6-6005-42b4-a22e-682b4e3ee7fe.png" alt="image.png"></p>
<p>从上图中可以看出变成全表扫描了，由此可见在索引列上有计算，索引会失效。</p>
<h3 id="heading"></h3>
<p><strong>索引列上使用了函数</strong></p>
<p>如果在索引列加某个函数，具体sql如下：</p>
<pre><code>explain select * from newrank_user where SUBSTR(rank,1,1)=8;
</code></pre><p>结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618317922835-5571c688-5896-46ee-a26e-23fb75f2799e.png" alt="image.png"></p>
<p>从上图中可以看出变成全表扫描了，由此可见在索引列上加了函数，索引也会失效。</p>
<p><strong>字符类型没加引号</strong></p>
<p>上sql：</p>
<pre><code>explain select * from newrank_user where name = 123;
</code></pre><p>结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618318021271-4bff8842-9140-470e-a1d4-2a230f63556d.png" alt="image.png"></p>
<p>从图中看出走的全表扫描，索引失效了。</p>
<p>为什么索引会失效呢？</p>
<p>答：<code>name</code>字段是<code>字符类型</code>，而等于号右边的是<code>数字类型</code>，类型不匹配导致索引丢失。</p>
<p>所以在使用字符类型字段做判断时，一定要加上单引号。</p>
<blockquote>
<p>★类型不匹配导致索引丢失问题，是我们平时工作中非常容易忽视的问题，一定要引起足够的重视”</p>
</blockquote>
<p><strong>用is null和is not null没注意字段是否允许为空</strong></p>
<p>前面创建的newrank_user表中rank字段是非空的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618318179379-55a67b56-e876-45ff-9deb-fb7507468da7.png" alt="image.png"></p>
<p>查询sql如下：</p>
<pre><code>explain select * from newrank_user where  rank is null;
explain select * from newrank_user where  rank is not null;
</code></pre><p>结果都是：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618318328094-c63b92fd-e8d9-42e3-b931-9ca0dc1ce787.png" alt="image.png"></p>
<p>从上图中看出都是全表扫描，索引都失效了。</p>
<p>如果rank字段改成允许为空的呢？</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618318346330-83b1729d-bcf4-4749-a815-1bacbf7822f0.png" alt="image.png"></p>
<p>上面第一条sql执行结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618318886339-bb151963-034a-44c2-9dc5-1cb6db45dce4.png" alt="image.png"></p>
<p>从上图中看出走了<code>ref</code>类型的索引。</p>
<p>上面第二条sql执行结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618318900734-6b6bb3fe-73bb-4e39-b02b-ff9fc948f22a.png" alt="image.png"></p>
<p>从上图中看出并未走索引，这块存在疑问需要看对应场景的量级和执行优化器的选择。</p>
<p><strong>小结</strong></p>
<ol>
<li>如果字段不允许为空，则is null 和 is not null这两种情况索引都会失效。</li>
<li>如果字段允许为空，则is null走<code>ref</code>类型的索引，注意的是is not null需要根据实际的数据量级和执行优化器的选择会不会走索引。</li>
</ol>
<p><strong>like查询左边有%</strong></p>
<p>like查询主要有三种情况：</p>
<ul>
<li>like &lsquo;%a&rsquo;</li>
<li>like &lsquo;a%&rsquo;</li>
<li>like &lsquo;%a%&rsquo;</li>
</ul>
<p>第一种情况：</p>
<pre><code>explain select * from newrank_user where  code like '%001';
</code></pre><p>结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618369837254-6ee6c56e-8430-4080-9c92-792fbf98c5a7.png" alt="image.png"></p>
<p>从上图看出走的全表扫描，索引失效了。</p>
<p>第二种情况：</p>
<pre><code>explain select * from newrank_user where  code like '001%';
</code></pre><p>结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618369901912-4fe63315-5039-4017-88fd-86711cc904cf.png" alt="image.png"></p>
<p>从上图看出走的<code>range</code>类型的索引。</p>
<p>最后看看第三种情况：</p>
<pre><code>explain select * from newrank_user where  code like '%001%';
</code></pre><p>结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618369837254-6ee6c56e-8430-4080-9c92-792fbf98c5a7.png" alt="image.png"></p>
<p>从上图看出走的全表扫描，索引也失效了。</p>
<p>从这三种结果看出<code>like</code>语句只有<code>%</code>在右边才能走索引。</p>
<p>如果有些场景就是要使用<code>like</code>语句<code>%</code>在左边该怎么办呢？</p>
<p>答案：使用覆盖索引</p>
<p>具体sql如下：</p>
<pre><code>explain select code,age,name from newrank_user where  code like '%001%';
</code></pre><p>结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618370455263-eac1a32b-fbe4-417a-bbe9-65dd07938376.png" alt="image.png"></p>
<p>从上图看出走的<code>index</code>类型的全索引扫描，相对于全表扫描性能更好。</p>
<p>当然，最佳实践是在<code>sql</code>中要避免<code>like</code>语句<code>%</code>在左边的情况，如果有这种业务场景可以使用<code>es</code>代替<code>mysql</code>存储数据。</p>
<p>小结：</p>
<ul>
<li>like &lsquo;%a&rsquo; 索引失效</li>
<li>like &lsquo;a%&rsquo; 走range类型索引</li>
<li>like &lsquo;%a%&rsquo; 索引失效</li>
</ul>
<p><strong>使用or关键字时没有注意</strong></p>
<pre><code>explain select * from newrank_user where  code = '001'or rank = 8;
</code></pre><p>结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618372591274-b5cbdfdd-2fe0-4244-ad16-267d94e242ee.png" alt="image.png"></p>
<p>从上图中可以看出变成了全表扫描，索引失效了。</p>
<p>我们不妨单独查询一下：</p>
<pre><code>explain select * from newrank_user where  code = '001';
</code></pre><p>结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618372653843-aec32977-bd17-4395-b835-beeae54b0c0b.png" alt="image.png"></p>
<p>和</p>
<pre><code>explain select * from newrank_user where  rank = 8;
</code></pre><p>结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618372669920-3cf436ed-583e-4d82-bd8b-ef1c401264b0.png" alt="image.png"></p>
<p>两种单独查询的情况都走了<code>ref</code>类型的索引，但是使用<code>or</code>关键字后sql的索引会失效。</p>
<p>那么，我们在想使用<code>or</code>的场景，又想让索引有效，该怎么办呢？</p>
<pre><code>explain (select * from newrank_user where   code = '001') 
union (select * from newrank_user where  rank = 8);
</code></pre><p>没错，使用<code>union</code>关键字，但是跟<code>or</code>关键字的语法稍微有点区别，不过查询的数据结果是一样的。</p>
<p>上面sql执行结果如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618372725845-5fbf8aa3-e782-49d6-a79f-ffa7067ff55a.png" alt="image.png"></p>
<p>我们看到走了<code>ref</code>类型索引。</p>
<blockquote>
<p>★or关键字会让索引失效，可以用union代替”</p>
</blockquote>
<p><strong>编码集不同导致关联查询索引失效</strong></p>
<p>创建一张新表，插入部分数据：</p>
<pre><code>#创建表 指定code编码集为uft8
CREATE TABLE `newrank_role` (
  `id` bigint UNSIGNED NOT NULL,
  `code` varchar(32) CHARACTER SET utf8 NOT NULL,
    `role` int NOT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_code` (`code`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
#插入部分测试数据
INSERT INTO `newrank_role`(`id`, `code`, `role`) VALUES (1, '001',1);
INSERT INTO `newrank_role`(`id`, `code`, `role`,) VALUES (2, '002',3);
INSERT INTO `newrank_role`(`id`, `code`, `role`,) VALUES (3, '003',2);
</code></pre><p>执行如下sql:</p>
<pre><code>EXPLAIN SELECT * from newrank_user a
LEFT JOIN newrank_role b on a.code = b.code
where a.`code` = '001'
</code></pre><p>执行计划：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618392804556-2204b6cd-1b5e-439a-b03e-9a94367602e1.png" alt="image.png"></p>
<p>由上图可见虽然b表的code 存在索引但因为编码集不统一导致了b表全表扫描；</p>
<p>修改newrank_role表code编码集为utf8mb</p>
<p>再次查看上述执行sql 的执行计划：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1409622/1618392997896-1011ff63-54a1-496c-8b17-a14a336403e6.png" alt="image.png"></p>
<p>发现能够命中索引</p>
<p>示例使用到的(需对应数据库版本看待)sql:</p>
<p><a href="https://newrank.yuque.com/attachments/yuque/0/2021/sql/1409622/1618471588410-e25c489c-35fb-46ed-8fa9-b98684dc4557.sql">📎mysql索引失效讲解示例.sql</a></p>
<h2 id="备注">备注</h2>
<ul>
<li><strong>以上大部分规约来自阿里的java开发规范手册，建立公司自己的规范需要各位同学的添砖加瓦和不断累积，希望各位同学踊跃参与到规范的建设当中来。如果发现本规约中存在错误描述或者有新的规约需要加入《新榜mysql规约中》可以再文档下方进行评论，联系规约维护人，线下沟通确认；</strong></li>
</ul>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
